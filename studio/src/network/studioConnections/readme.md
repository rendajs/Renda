# Studio Connections

Studio connections allow us to link multiple studio instances together and have them communicate with each other.
Additionally, inspector connections can be made to running applications,
allowing you to inspect or modify scenes at runtime.

Since a lot of functionality needs to also be bundled with applications,
a large portion of the documentation (and code) can be found [here](../../../../src/network/studioConnections/readme.md).

# Security

Since Studio Connections could potentially allow anyone to gain access to a project,
a lot of security implications need to be taken into account.
`studio-client` connections can read from and even write to a project,
so we need to make sure connections are only accepted when we know the connection is trusted.

Apart from that, we also need to take into account the broadcasting of project metadata.
A user might not expect this data to be available publicly so it could contain sensitive info
such as project names of unreleased projects.

## WebRTC Connections

WebRTC Connections are disabled by default.
Only when the `studioConnections.enableRemoteDiscovery` preference is enabled, do we connect to the
discovery WebSocket. So no project metadata is being broadcast until this preference is explicitly enabled.

When connections are requested, we still don't want to automatically accept them though.
TODO #812
Instead, we'll show an indication with UI that an available connection wishes to connect, and the user has to
explicitly accept the connection.

## Internal Connections

We will always want to have a listening internal discovery method, because of the reasons described below,
but we still don't want to expose project metadata.
Since any site could create an internal discovery manager, any third-party site the user visits could
try to grab the project metadata from their visitors.
Therefore, we use `studioConnections.enableInternalDiscovery` to enable or disable broadcasting
metadata using the internal discovery method.

We will also block connections except those described below.
This preference has to be enabled for incoming connections to be accepted.
Especially since #812 hasn't been implemented yet.

## Connections That Are Always Accepted

The UI permission permission prompt (TODO #812) works well as a
general safety net against malicious actors trying to make connections.
But there a some scenarios where we can get away with not prompting the user,
scenarios where these prompts could actually be pretty cumbersome.

### Opened by the Build View Content Window

If a page has been opened by the build view, we'll assume the content of the page is always trusted.
The iframe can postmessage to the studio instance using a `ParentStudioCommunicator` and request a connection token.
They can then use this token when initiating the connection via the discovery manager.

### Hosted by the Current Studio Instance

TODO: #810
If the page is being hosted by the current studio instance, the connection can also be trusted because
the current studio instance is responsible for hosting the scripts.
Files hosted by a studio make use of its service worker, causing URLs like
`/sw/clients/<client-id>/projectFiles/<path-to-project-file>`
to respond with files from a specific studio instance.
We can compare the value of `<client-id>` to that of our own to determine whether the page was generated by us.
We also need to ensure the origin is the same, although the chance of a page guessing our client id is pretty slim.

### Allowlisted Origins for Internal Connections

TODO: #749, #751
We want to allow the user to specify a list of origins that are always automatically accepted.
To figure out the origin of a connection, we can take a look at the `document.referrer` value in the
case of the internal discovery method iframe.
The WebRTC discovery server can look at the Referrer header.

## Spoofing the Referrer
One thing to keep in mind is the fact that origins or referrers can be spoofed.

This is not a problem for the referrer of the internal discovery method though.
This can only be spoofed if the browser or OS is compromised.
At that point, the attacker already has access to the project files.
The referrer is useful for making sure other sites that the user visits aren't trying to connect to a project of that user.
And with a secure browser, third-party sites are not able to spoof the referrer.

The same can't be said for WebRTC connections, unfortunately.
While we can look at the origin header when a connection is made to the discovery WebSocket,
an attacker isn't operating from the user's own device in this case.
Therefore, the allow list shouldn't apply to WebRTC connections.
Instead, these should always show a permission prompt.

In the future, we might be able to work around this problem by allowing the user to
provide a room id, which is protected with a password.
That way any connection in that room can be expected to be trusted as well.
